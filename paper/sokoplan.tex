% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{subcaption}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{AI Guided Design of Sokoban Puzzles based on Automated Planning}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Tom\'a\v{s} Balyo\inst{1} \and
Nils Froleyks\inst{2}}
%
\authorrunning{Tom\'a\v{s} Balyo, Nils Froleyks}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{CAS Software AG, Karlsruhe, Germany\\
\email{tomas.balyo@cas.de}
\and
Johannes Kepler University, Linz, Austria\\
\email{nils.froleyks@jku.at}}
%
\maketitle              % typeset the header of the contribution

%macros for sokoban level figures
\newcommand{\sokoimg}[1]{\includegraphics[scale=1.5]{#1} \hspace{-0.30em}}

\newcommand{\w}{\sokoimg{figures/wall.pdf}}
\newcommand{\e}{\sokoimg{figures/empty.pdf}}
\newcommand{\p}{\sokoimg{figures/player.pdf}}
\newcommand{\x}{\sokoimg{figures/box.pdf}}
\newcommand{\g}{\sokoimg{figures/goal.pdf}}
\newcommand{\h}{\sokoimg{figures/goalbox.pdf}}
\newcommand{\n}{\\
\vspace{-0.1em}}

%
\begin{abstract}
Designing interesting and challenging levels for a puzzle game is a very difficult and time
consuming task. It is often possible to develop random puzzle generators that can produce
solvable levels. However, in order to obtain appealing levels, usually a human designer 
needs to be involved. In this paper we propose a new generic method for assisting human
designers to create solvable levels for a puzzle game by using Automated Planning. 
We will demonstrate our method on the well-known Japanese puzzle game Sokoban.

\keywords{Sokoban \and Automated Planning \and Puzzle Generation}
\end{abstract}
%
%
%
\section{Introduction}
Sokoban is a puzzle game that originated in Japan. It was invented by Hiroyuki
Imabayashi, and published in 1982 by Thinking Rabbit, as a PC game~\cite{TODO}.
The word Sokoban is Japanese for warehouse keeper.
Each puzzle represents a warehouse, where boxes are randomly placed. A warehouse
keeper (the player) has to push the boxes around the warehouse so that all boxes 
end up in designated goal positions.

The game of Sokoban is a complicated computational problem. It was first proven
to be NP-hard \cite{dorit96} and then PSPACE-complete \cite{culberson97}. While
the rules are simple, even small levels can require a lot of computation to be
solved. Designing interesting solvable levels is also challenging and a subject
of academic research~\cite{murase1996automatic,taylor2011procedural,kartal2016data,de2019procedural}.

Automated planning~\cite{TODO} is one of the central techniques in artificial intelligence.
The task of planning is to find a sequence of actions, i.e., a plan, that transforms the world
from a given initial state to a goal state, i.e., a state that satisfies the given goal conditions.
Planning is a very competitive research area and there exist multiple high performance planning
tools that are constantly being developed and improved~\cite{TODO}.

In this paper we will demonstrate how the power of automated planning tools can be utilized
to design a system that can generate challenging solvable puzzles and intelligently assist
a human puzzle designer. To our best knowledge, this is the first time, that automated planning has 
been used in this context.

We will demonstrate our technique on the example of Sokoban puzzles, since this is well known
and well studied game. Nevertheless, the technique can be used for any puzzle game that satisfies
the following conditions:
\begin{itemize}
\item Single player -- the game is played by a single player. There may exist helpful or adversary agents
in the game as long as their behavior is fully deterministic and specified by simple rules.
\item Finite and discrete game world -- each game state can be fully described with finitely many
 finite domain variables.
\item Deterministic game play -- random events or random outcomes of player actions are not allowed.
\item Full observability -- there are no hidden or unknown elements that influence the game play.
\end{itemize}

The rest of the paper is organized as follows. In the next section we will provide the preliminary definitions
of automated planning and the rules of Sokoban. Then we will review the related work in the
area of procedural generation of Sokoban levels. Following that we will describe our new
method and our new tool that implements it. Finally, we will present an evaluation of our tool and show
examples of generated levels.

\section{Preliminaries}

\subsection{Automated Planning}
As we already briefly stated in the introduction, planning is the task of finding a plan (a sequence of
actions) that transforms the world from a given initial state to a goal state that satisfies the
goal conditions. How to represent the world states, goal conditions, and describe the set of possible actions is
defined in this Subsection.

Planning problems are modeled using the Planning Domain Definition Language (PDDL)~\cite{TODO}, which is
based on the programming language LISP~\cite{TODO}. PDDL is a very rich language with many features, however, we
will only require a small subset of it which we will describe below.

The basic building blocks of PDDL are \emph{Objects} and \emph{Types}. Each object is of a certain
type. For example if we define a type "city" then we can define the objects "Paris", "London", and "Madrid" of
the type "city". Another type could be "person" and the objects of this type are for example "Alice" and "John".
In PDDL we would express this using the following lines:

\begin{verbatim}
(:types city person - object)
(:objects 
  Paris London Madrid - city
  Alice John - person
)
\end{verbatim}

In PDDL we can refer to objects using variables. Variable names always start with a question mark "?" and each
variable has a type. For example a variable "c" of the type "city" would be declared as: \verb _(?c - city)_.

Variables appear in \emph{Predicates}, which are atomic statements that are used to express certain
conditions. For example, a predicate called "livesIn" could could have two parameters, one of the type "person"
and one of the type "city". In PDLL we would declare this predicate as \verb _(livesIn ?p - person ?c - city)_
and it would mean that an object of type "person" lives in an object of type "city". Using the predicate
we can now declare facts about our objects by substituting variables with objects of the proper type, for example:

\verb _(livesIn Alice Madrid), (livesIn John London)_.

The last building block of PDDL that we need are operators, which can be intuitively understood as templates
for actions. Actions change the world state by modifying the truth values of predicates. An action $a$ consists
of a name $name(a)$, a set of preconditions $pre(a)$ and a set of effects $eff(a)$. 
Both preconditions and effects are sets of grounded
predicates (predicates where all variables are substituted by objects). 
\begin{enumerate}
\item Preconditions represent the predicates
that must be true in the given world state in order to execute the action. We say that an action $a$
is applicable in a given world state $s$ if and only if all predicates in $pre(a)$ hold true in $s$.
\item Effects are used to update the world state after the action is executed. Positive effects are
predicates that will become true (unless they are already true) after the action is executed. Negative
effects are negated predicates and they become false. The state of all the other predicates that are not
involved in the effects of the executed actions must remain unchanged.
\end{enumerate}
The following is an example of an action representing moving Alice form Madrid to Paris:
\begin{verbatim}
(:action move-Alice-Madrid-Paris
  :precondition (and
    (livesIn Alice Madrid)
  )
  :effect (and
    (not (livesIn Alice Madrid))
    (livesIn Alice Paris)
  )
)
\end{verbatim}
The precondition is that Alice lives in Madrid and the effects are that Alice does not live in Madrid anymore and
she lives in Paris. If we wish to model all possible movements for both Alice and John and the three cities, we
would need to write down 12 actions that are very similar to each other. A better solution is to use the
already mentioned operators, i.e., action templates. Operators look like actions with the difference that they
may have parameters and use predicates with variables in the preconditions and effects. An operator for
the move actions would be declared as follows:
\begin{verbatim}
(:action move
  :parameters(?p - person ?from ?to - city)
  :precondition (and
    (livesIn ?p ?from)
  )
  :effect (and
    (not (livesIn ?p ?from))
    (livesIn ?p ?to)
  )
)
\end{verbatim}
A planner would then generate all the possible actions from this template by substituting all the possible
combinations of objects for the three parameters. This process is referred to as grounding.

Now we have everything we need to fully describe a planning problem in PDDL, which consists of the following
elements:
\begin{enumerate}
\item set of used types
\item set of predicates
\item set of operators
\item list of all the objects in the problem together with their types
\item the initial state of the world in the form of grounded predicates (predicates with objects substituted for
all variables).
\item the goal conditions in the form of grounded predicates.
\end{enumerate}

When describing a planning problem in PDDL we split the description into two files: domain.pddl and problem.pddl.
The first file, domain.pddl contains the types, predicates, and operators. The rest in written in the problem.pddl
file. Four our moving example the domain.pddl would look like:.

\begin{verbatim}
(define (domain moving)
  (:requirements :strips :typing)
  (:types city person - object)
  (:predicates
    (livesIn ?p - person ?c - city)
  )
  (:action move
    :parameters(?p - person ?from ?to - city)
    :precondition (and
      (livesIn ?p ?from)
    )
    :effect (and
      (not (livesIn ?p ?from))
      (livesIn ?p ?to)
    )
  )
)
\end{verbatim}
and the problem.pddl would contain:
\begin{verbatim}
(define (problem moving-1)
  (:domain moving)
  (:requirements :strips :typing)
  (:objects
    Paris London Madrid - city
    Alice John - person
  )
  (:init
    (livesIn Alice Madrid)
    (livesIn John London)
  )
  (:goal (and
    (livesIn Alice Paris)
    (livesIn John Paris)
  ))  
)
\end{verbatim}
The domain file file describes the general planning problem of moving people between cities, while the problem
file describes the concrete problem instance of moving John and Alice from London and Madrid to Paris.
An automated planner would now take these two files and find a plan, which in this case would consist of two
actions: \verb _move-alice-madrid-paris_ and \verb _move-john-london-paris_.

Since automated planning is very competitive research field, it is easy to find very well performing
planning tools that are freely available on the internet. One way to choose a good planner is to look
at the International Planning Competition website~\cite{TODO}, where state-of-the-art planners are evaluated 
and compared in regular time intervals.


\subsection{Sokoban}

Each Sokoban level consists of a two dimensional rectangular grid of squares that make
up the "warehouse" (See Figure~\ref{fig-basic-level} for an example). 
If a square contains nothing it is called a floor. Otherwise it is occupied by
one of the following entities (see Figure~\ref{fig-tiles}):

\begin{itemize}
\item \emph{Wall.} Walls make up the basic outline of each level. They cannot be
  moved and nothing else can be on a square occupied by a wall. A legal level is
  always surrounded by walls.

\item \emph{Box.} A box can either occupy a goal or an otherwise empty square. It can be
  moved in the four cardinal directions by \emph{pushing} (see below).

\item  \emph{Goal.} Goals are treated like floors for the most part. Only when
  each goal is occupied by a box the game is completed. In a legal level the
  number of goals matches the number of boxes. For the sake of simplicity, we
  will call a square that is either a goal or a floor square \emph{free} since
  the worker and boxes can enter both.

\item \emph{Worker.} There must be exactly one worker in each level.
  It is the only element that is directly controlled by the player.
\end{itemize}

\begin{figure}
\centering
\w\e\x\e\g\e\p\n
\caption{The four kinds of tiles that make up a Sokoban warehouse: Wall, Box, Goal, and Worker (from left to right).}.
\label{fig-tiles}
\end{figure}


\begin{figure}
\centering
\w\w\w\w\w\w\e\w\w\w\w\w\w\n
\w\p\e\x\g\w\e\w\e\e\p\h\w\n
\w\w\w\w\w\w\e\w\w\w\w\w\w\n
\caption{A simple Sokoban level in its initial (left) and solved (right) state. 
The solution to this level consists of two steps: MOVE-RIGHT and PUSH-RIGHT.}.
\label{fig-basic-level}
\end{figure}

There are two kind of moves in Sokoban:
\begin{enumerate}
\item \emph{Move the worker.} The worker can be moved in the four cardinal directions (up, down, left, right)
by one square in each step.
This movement is directly controlled by the player. The worker may be moved onto an adjacent free square.
\item \emph{Push a box.} The worker can push a box in a certain direction if the square behind the box is free.
To be precise, there are always three squares (A,B,C) involved in a push move. The first (A) contains the worker, the
second (B) contains a box and the third one (C) is a free (empty or goal) square. 
These three squares must form a single
line of adjacent squares. After the push is performed, the box occupies the free square (C) and the worker occupies
the square formerly occupied by the box (B).
\end{enumerate}

The goal of the game is to find a \emph{solution}, which
is a sequence of moves and pushes. Executing a solution leads to every box
being on a goal. It does not matter which box ends up on which goal.
A level may have no solution. Such a level is undesirable and should not be presented to a human player
for obvious reasons.

\section{Related Work}
The first published Sokoban level generator algorithm is by Murase et al.~\cite{murase1996automatic}.
Their approach has three phases.
\begin{enumerate}
\item \emph{Generate random levels}. In this phase predefined templates of walls are placed randomly
over a prototype level consisting of only walls. 
The templates are placed such that they are connected by passages.
Then boxes and goal tiles are placed randomly.
\item \emph{Filter out unsolvable levels}. Phase one may generate levels that have no solution. According to the the authors this happens in around half of the cases. In this phase they use a sokoban solver to try to find a solution and filter out unsolvable levels.
\item \emph{Evaluation}. In this phase the levels are automatically evaluated to determine whether
they are interesting. The evaluation is based on simple metrics such as the length of the solution, the number of changes in directions when pushing a box and the number of detours.
\end{enumerate}

The complexity of this approach is dominated by phase two -- filtering out unsolvable levels. This
step requires solving Sokoban problems, which is a PSPACE-complete problem~\cite{culberson1997sokoban}.

The approach of Taylor and Parberry~\cite{taylor2011procedural} is similar to Murase et al.
in that they first generate a random level based on placing templates of walls. Then they
randomly place goals with boxes on them in the rooms. At this point they 
actually have a solved Sokoban
puzzle. In the following stage they ``unsolve'' the level by doing reverse Sokoban moves, i.e., 
pulling boxes away from the goals. The aim of this stage is to reach a state that is far as 
possible from the solved state. They do this by running an iterative deepening search of the
state space.

The complex part of this algorithm is the search for the starting state in the second stage. 
The process is very memory intensive, since all the visited states have to be kept in 
memory in order to avoid looping. On the other hand, the algorithm has the anytime property, i.e., it 
can be stopped at any time to return a valid solution, however, letting it run longer will yield
a better solution.

In \cite{taylor2015attention} an auditory Stroop test was performed to compare the engagement of
players while playing hand-crafted Sokoban levels against levels generated by the approach of 
Taylor and Parberry~\cite{taylor2011procedural}. The experiment showed that players found
procedurally generated levels equally interesting to hand-crafted levels. This demonstrates
that there is entertainment value in procedurally generated puzzles.

Kartal et al.~\cite{kartal2016data} propose a Monte Carlo tree search (MCTS) based Sokoban level
generator. They formulate puzzle generation as an MCTS optimization problem such that the puzzles
are generated through simulated game play. The search process starts with a level full of walls except
for one tile, which contains the player in its start position. The following actions are possible at each
node of the search tree:
\begin{enumerate}
\item \emph{Remove a Wall.} Choose a wall that is adjacent to an empty tile and remove it. By only removing walls
adjacent to empty tiles they can ensure that no unreachable rooms are generated.
\item \emph{Place a Box.} Choose an empty tile and put a box there.
\item \emph{Freeze the Level.} With this action the search is changed to play mode. Removing walls and placing
boxes is not allowed after this action. The current positions of walls, boxes and the player constitute 
the starting state of the level (without any goal positions, they will be defined later).
\item \emph{Move the Player.} Simulate play by executing legal moves of the player, i.e., walking 
around and pushing boxes.
\item \emph{Evaluate the Level.} This is the final action of each search path. The current positions of the boxes
are declared to be the goal locations and the quality of the generated level is estimated based on data driven
evaluation functions.
\end{enumerate}

Similarly to the previously presented method, this generator also has the anytime property. It is capable of
producing a wide variety of levels thanks to its stochastic nature. Nevertheless, like all the presented approaches,
it has its limitations and the generation of large puzzles remains a bottleneck as the 
number of possible level designs grows exponentially.

An up-to-date survey on procedural puzzle generation~\cite{de2019procedural} gives an overview
of the methods for generating puzzles for many games similar to Sokoban.

\section{Puzzle Generation as Planning}
Our proposed approach is based on the idea of using automated planners to generate solvable Sokoban levels.
This means that our only task is to express the problem of level generation in PDDL and the rest is taken care of
by the planning tool. We will formulate the problem of Sokoban level generation as an extension of Sokoban
level solving.

\subsection{Sokoban Solving as Planning}
Using automated planning to solve Sokoban is not a new idea by any means. Actually, Sokoban is one of the
standard benchmark problems used to evaluate new planning algorithms and tools in many academic papers
and the international planning competition~\cite{TODO}. Nevertheless, in order to keep this paper self-contained,
we will present a simple PDDL encoding of Sokoban in this Subsection.

To encode Sokoban solving we will only require one kind of objects -- squares. We will have one
object of type square for each location in the level that is not a wall. Additionally, we will
need the following predicates:
\begin{enumerate}
\item \verb _(above ?a ?b - square)_ meaning that square "a" is above square "b"
\item \verb *(left_of ?a ?b - square)* meaning that square "a" is on the left side of square "b"
\item \verb *(box_at ?a - square)* meaining that there is a box at square "a"
\item \verb *(worker_at ?a - square)* meaining that there is the worker at square "a"
\end{enumerate}
To complete the domain description we need to specify the operators. We will need two kinds
of operators -- move and push and we will need 4 of each for the 4 cardinal directions (up, down, left, right).
Fist, we will describe the move-up operator:
\begin{verbatim}
(:action move_up
  :parameters (?from ?to - square)
  :precondition(and
    (above ?to ?from)
    (worker_at ?from)
    (not (box_at ?to))
  )
  :effect (and
    (not (worker_at ?from))
    (worker_at ?to)    
  )
)
\end{verbatim}
The operators for moving down, left, and right are analogous, they only differ on the line with
\verb *(above ?to ?from)* where move-down has \verb *(above ?from ?to)*, move-left has
\verb *(left_of ?to ?from)* and move-right has \verb *(left_of ?from ?to)*.
Next we describe the push-up operator:
\begin{verbatim}
(:action push_up
  :parameters (?from ?to ?box_to - square)
  :precondition(and
    (above ?to ?from)
    (above ?box_to ?to)
    (worker_at ?from)
    (box_at ?to)
    (not (box_at ?box_to))
  )
  :effect (and
    (not (worker_at ?from))
    (worker_at ?to)    
    (not (box_at ?to))
    (box_at ?box_to)
  )
)
\end{verbatim}
Like int the case of move operators, the other three push operators (push down, left, and right) only differ
on the lines with the "above" predicates.

What remains is to specify the initial state and the goal conditions. For the initial state we need to declare
the following predicates:
\begin{enumerate}
\item \verb *(above a b)* for each pair of non-wall squares such that "a" is above "b".
\item \verb *(left_of a b)* for each pair of non-wall squares such that "a" is on the left side of "b".
\item \verb *(box_at a)* for each square "a" that contains a box.
\item \verb *(worker_at a)* for the square "a" that contains the worker.
\end{enumerate}
As for the goal conditions, we only need to specify that the goal squares must contain a box:
\begin{enumerate}
\item \verb *(box_at a)* for each square "a" that contains a goal.
\end{enumerate}
An example of a Sokoban level and its encoding in given on Figure~\ref{fig-solve-example}.

\begin{figure}
\begin{subfigure}[b]{0.35\textwidth}
\centering
\w\w\w\w\e\n
\w\e\p\w\e\n
\w\x\w\w\w\n
\w\e\x\g\w\n
\w\g\w\w\w\n
\w\w\w\e\e\n
\vspace{1em}
\end{subfigure}
\begin{subfigure}[b]{0.65\textwidth}
\begin{verbatim}
(:objects
  s11 s12 s21 s31 s32 s33 s41 - square
)
(:init
  (above s11 s21) (above s21 s31)
  (above s31 s41) (left_of s11 s12)
  (left_of s31 s32) (left_of s32 s33)
  (box_at s21) (box_at s32) (worker_at s12)
)
(:goal (and
  (box_at s41) (box_at s33)
))
\end{verbatim}
\end{subfigure}
\caption{A Sokoban level (left) and its encoding in PDDL (right)}
\label{fig-solve-example}
\end{figure}



\subsection{Level Creation as Planning}


\subsection{Dealing with Trivial Levels}
The planner tries to find short plans, it will try to place boxes next to goals

solution: minimal number of pushes

\section{Experimental Evaluation}
how does it scale?

what is the largest level we can create?

\section{Conclusion}
\subsection{Future Work}

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{references, literatur}
%
\end{document}
