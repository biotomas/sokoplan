% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{colortbl}
\hypersetup{
  colorlinks=true,
  allcolors=black,
  urlcolor=blue
}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{AI Assisted Design of Sokoban Puzzles using Automated Planning}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Tom\'a\v{s} Balyo\inst{1} \and
Nils Froleyks\inst{2}}
%
\authorrunning{Tom\'a\v{s} Balyo, Nils Froleyks}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{CAS Software AG, Karlsruhe, Germany\\
\email{tomas.balyo@cas.de}
\and
Johannes Kepler University, Linz, Austria\\
\email{nils.froleyks@jku.at}}
%
\maketitle              % typeset the header of the contribution

%macros for sokoban level figures
\newcommand{\sokoimg}[1]{\includegraphics[scale=1.5]{#1} \hspace{-0.30em}}

\newcommand{\w}{\sokoimg{figures/wall.pdf}}
\newcommand{\e}{\sokoimg{figures/empty.pdf}}
\newcommand{\p}{\sokoimg{figures/player.pdf}}
\newcommand{\x}{\sokoimg{figures/box.pdf}}
\newcommand{\g}{\sokoimg{figures/goal.pdf}}
\newcommand{\h}{\sokoimg{figures/goalbox.pdf}}
\newcommand{\n}{\\
\vspace{-0.1em}}

%
\begin{abstract}
Designing interesting and challenging levels for a puzzle game is a very difficult and time
consuming task. It is often possible to develop random puzzle generators that can produce
solvable levels. However, in order to obtain appealing levels, usually a human designer 
needs to be involved. In this paper we propose a new generic method for assisting human
designers to create solvable levels for a puzzle game by using Automated Planning. 
We will demonstrate our method on the well-known Japanese puzzle game Sokoban.

\keywords{Sokoban \and Automated Planning \and Puzzle Generation}
\end{abstract}
%
%
%
\section{Introduction}
Sokoban is a puzzle game that originated in Japan. It was invented by Hiroyuki
Imabayashi, and published in 1982 by Thinking Rabbit \cite{SokobanOfficial}.
The word Sokoban is Japanese for warehouse keeper.
Each puzzle represents a warehouse, where boxes are randomly placed. A warehouse
keeper (the player) has to push the boxes around the warehouse so that all boxes 
end up in designated goal positions.

The game of Sokoban is a complicated computational problem. It was first proven
to be NP-hard \cite{dorit96} and later PSPACE-complete \cite{culberson97}. While
the rules are simple, even small levels can require a lot of computation to be
solved. Designing interesting solvable levels is also challenging and a subject
of academic research~\cite{murase1996automatic,taylor2011procedural,kartal2016data,de2019procedural}.

Automated planning~\cite{ghallab2016automated} is one of the central techniques in artificial intelligence.
The task of planning is to find a sequence of actions, i.e., a plan, that transforms the world
from a given initial state to a goal state, i.e., a state that satisfies the given goal conditions.
Planning is a very competitive research area and there exist multiple high performance planning
tools that are constantly being developed and improved~\cite{ipc}.

In this paper we will demonstrate how the power of automated planning tools can be utilized
to design a system that can generate challenging solvable puzzles and intelligently assist
a human puzzle designer. To our best knowledge, this is the first time, that automated planning has
been used in this context.

We will demonstrate our technique on the example of Sokoban puzzles, since this is well known
and well studied game. Nevertheless, the technique can be used for any puzzle game that satisfies
the following conditions:
\begin{itemize}
\item Single player -- the game is played by a single player. There may exist helpful or adversary agents
in the game as long as their behavior is fully deterministic and specified by simple rules.
\item Finite and discrete game world -- each game state can be fully described with finitely many
 finite domain variables.
\item Deterministic gameplay -- random events or random outcomes of player actions are not allowed.
\item Full observability -- there are no hidden or unknown elements that influence the gameplay.
\end{itemize}

The rest of the paper is organized as follows. In the next section we will provide the preliminary definitions
of automated planning and the rules of Sokoban. Then we will review the related work in the
area of procedural generation of Sokoban levels. Following that we will describe our new
method and our new tool that implements it. Finally, we will present an evaluation of our tool and show
examples of generated levels.

\section{Preliminaries}

\subsection{Automated Planning}
As we already briefly stated in the introduction, planning is the task of finding a plan (a sequence of
actions) that transforms the world from a given initial state to a goal state that satisfies the
goal conditions. How to represent the world states, goal conditions, and describe the set of possible actions is
defined in this Subsection.

Planning problems are modeled using the Planning Domain Definition Language (PDDL)~\cite{haslumIntroductionPlanningDomain2019a}, which is
based on the programming language LISP~\cite{lisp86}. PDDL is a very rich language with many features, however, we
will only require a small subset of it which we will describe below.

The basic building blocks of PDDL are \emph{Objects} and \emph{Types}. Each object is of a certain
type. For example if we define a type "city" then we can define the objects "Paris", "London", and "Madrid" of
the type "city". Another type could be "person" and the objects of this type are for example "Alice" and "John".
In PDDL we would express this using the following lines:

\begin{verbatim}
(:types city person - object)
(:objects
  Paris London Madrid - city
  Alice John - person
)
\end{verbatim}

In PDDL we can refer to objects using variables. Variable names always start with a question mark "?" and each
variable has a type. For example a variable "c" of the type "city" would be declared as: \verb _(?c - city)_.

Variables appear in \emph{Predicates}, which are atomic statements that are used to express certain
conditions. For example, a predicate called "livesIn" could could have two parameters, one of the type "person"
and one of the type "city". In PDLL we would declare this predicate as \verb _(livesIn ?p - person ?c - city)_
and it would mean that an object of type "person" lives in an object of type "city". Using the predicate
we can now declare facts about our objects by substituting variables with objects of the proper type, for example:

\verb _(livesIn Alice Madrid), (livesIn John London)_.

The last building block of PDDL that we need are operators, which can be intuitively understood as templates
for actions. Actions change the world state by modifying the truth values of predicates. An action $a$ consists
of a name $name(a)$, a set of preconditions $pre(a)$ and a set of effects $eff(a)$.
Both preconditions and effects are sets of grounded
predicates (predicates where all variables are substituted by objects).
\begin{enumerate}
\item Preconditions represent the predicates
that must be true in the given world state in order to execute the action. We say that an action $a$
is applicable in a given world state $s$ if and only if all predicates in $pre(a)$ hold true in $s$.
\item Effects are used to update the world state after the action is executed. Positive effects are
predicates that will become true (unless they are already true) after the action is executed. Negative
effects are negated predicates (wrapped in $not$) and they become false. All other predicates that are not
involved in the effects of the executed actions remain unchanged.
\end{enumerate}
The following is an example of an action representing moving Alice form Madrid to Paris:
\begin{verbatim}
(:action move-Alice-Madrid-Paris
  :precondition (and
    (livesIn Alice Madrid)
  )
  :effect (and
    (not (livesIn Alice Madrid))
    (livesIn Alice Paris)
  )
)
\end{verbatim}
The precondition is that Alice lives in Madrid and the effects are that Alice does not live in Madrid anymore and
she lives in Paris. If we wish to model all possible movements for both Alice and John and the three cities, we
would need to write down 12 actions that are very similar to each other. A better solution is to use the
already mentioned operators, i.e., action templates. Operators look like actions with the difference that they
may have parameters and use predicates with variables in the preconditions and effects. An operator for
the move actions would be declared as follows:
\begin{verbatim}
(:action move
  :parameters(?p - person ?from ?to - city)
  :precondition (and
    (livesIn ?p ?from)
  )
  :effect (and
    (not (livesIn ?p ?from))
    (livesIn ?p ?to)
  )
)
\end{verbatim}
A planner would then generate all the possible actions from this template by substituting all the possible
combinations of objects for the three parameters. This process is referred to as grounding.

Now we have everything we need to fully describe a planning problem in PDDL, which consists of the following
elements:
\begin{enumerate}
\item set of used types
\item set of predicates
\item set of operators
\item list of all the objects in the problem together with their types
\item the initial state of the world in the form of grounded predicates (predicates with objects substituted for
all variables).
\item the goal conditions in the form of grounded predicates.
\end{enumerate}

When describing a planning problem in PDDL we split the description into two files: domain.pddl and problem.pddl.
The first file, domain.pddl contains the types, predicates, and operators. The rest in written in the problem.pddl
file. Four our moving example the domain.pddl would look like:

\begin{verbatim}
(define (domain moving)
  (:requirements :strips :typing)
  (:types city person - object)
  (:predicates
    (livesIn ?p - person ?c - city)
  )
  (:action move
    :parameters(?p - person ?from ?to - city)
    :precondition (and
      (livesIn ?p ?from)
    )
    :effect (and
      (not (livesIn ?p ?from))
      (livesIn ?p ?to)
    )
  )
)
\end{verbatim}
and the problem.pddl would contain:
\begin{verbatim}
(define (problem moving-1)
  (:domain moving)
  (:requirements :strips :typing)
  (:objects
    Paris London Madrid - city
    Alice John - person
  )
  (:init
    (livesIn Alice Madrid)
    (livesIn John London)
  )
  (:goal (and
    (livesIn Alice Paris)
    (livesIn John Paris)
  ))
)
\end{verbatim}
The domain file describes the general planning problem of moving people between cities, while the problem
file describes the concrete problem instance of moving John and Alice from London and Madrid to Paris.
An automated planner would now take these two files and find a plan, which in this case would consist of two
actions: \verb _move-alice-madrid-paris_ and \verb _move-john-london-paris_.

Since automated planning is very competitive research field, it is easy to find very well performing
planning tools that are freely available on the internet. One way to choose a good planner is to look
at the International Planning Competition website~\cite{ipc}, where state-of-the-art planners are evaluated
and compared in regular time intervals.


\subsection{Sokoban}

Each Sokoban level consists of a two dimensional rectangular grid of squares
% that make up the "warehouse"
(See Figure~\ref{fig-basic-level} for an example).
If a square contains nothing it is called a floor. Otherwise it is occupied by
one of the following entities (see Figure~\ref{fig-tiles}):
\vspace{-3pt}
\begin{itemize}
\item \emph{Wall.} Walls make up the basic outline of each level. They cannot be
  moved and nothing else can be on a square occupied by a wall. A legal level is
  always surrounded by walls.
\item \emph{Box.} A box can either occupy a goal or an otherwise empty square. It can be
  moved in the four cardinal directions by \emph{pushing} (see below).
\item  \emph{Goal.} Goals are treated like floors for the most part. Only when
  each goal is occupied by a box the game is completed. In a legal level the
  number of goals matches the number of boxes. For the sake of simplicity, we
  will call a square that is either a goal or a floor square \emph{free} since
  the worker and boxes can enter both.
\item \emph{Worker.} There must be exactly one worker in each level.
  It is the only element that is directly controlled by the player.
\end{itemize}

\begin{figure}
\centering
\w\e\x\e\g\e\p\n
\caption{The four kinds of tiles that make up a Sokoban warehouse: Wall, Box, Goal, and Worker (from left to right).}
\label{fig-tiles}
\end{figure}


\begin{figure}
\centering
\w\w\w\w\w\w\e\w\w\w\w\w\w\n
\w\p\e\x\g\w\e\w\e\e\p\h\w\n
\w\w\w\w\w\w\e\w\w\w\w\w\w\n
\caption{A simple Sokoban level in its initial (left) and solved (right) state.
The solution to this level consists of two steps: MOVE-RIGHT and PUSH-RIGHT.}
\label{fig-basic-level}
\end{figure}

There are two kind of moves in Sokoban:
\begin{enumerate}
\item \emph{Move the worker.} The worker can be moved in the four cardinal directions (up, down, left, right)
by one square in each step.
This movement is directly controlled by the player. The worker may be moved onto an adjacent free square.
\item \emph{Push a box.} The worker can push a box in a certain direction if the square behind the box is free.
To be precise, there are always three squares (A,B,C) involved in a push move. The first (A) contains the worker, the
second (B) contains a box and the third one (C) is a free (empty or goal) square.
These three squares must form a single
line of adjacent squares. After the push is performed, the box occupies the free square (C) and the worker occupies
the square formerly occupied by the box (B).
\end{enumerate}

The goal of the game is to find a \emph{solution}, which
is a sequence of moves and pushes. Executing a solution leads to every box
being on a goal. It does not matter which box ends up on which goal.
A level may have no solution. Such a level is undesirable and should not be presented to a human player
for obvious reasons.

\section{Related Work}
\label{sec-related}
TODO list and reference some Sokoban solvers

TODO list and reference some Sokoban level estimators

The first published Sokoban level generator algorithm is by Murase et al.~\cite{murase1996automatic}.
Their approach has three phases.
\begin{enumerate}
\item \emph{Generate random levels}. In this phase predefined templates of walls are placed randomly
over a prototype level consisting of only walls.
The templates are placed such that they are connected by passages.
Then boxes and goal tiles are placed randomly.
\item \emph{Filter out unsolvable levels}. Phase one may generate levels that have no solution. According to the the authors this happens in around half of the cases. In this phase they use a sokoban solver to try to find a solution and filter out unsolvable levels.
\item \emph{Evaluation}. In this phase the levels are automatically evaluated to determine whether
they are interesting. The evaluation is based on simple metrics such as the length of the solution, the number of changes in directions when pushing a box and the number of detours.
\end{enumerate}

The complexity of this approach is dominated by phase two -- filtering out unsolvable levels. This
step requires solving Sokoban problems, which is a PSPACE-complete problem~\cite{culberson1997sokoban}.

The approach of Taylor and Parberry~\cite{taylor2011procedural} is similar to Murase et al.
in that they first generate a random level based on placing templates of walls. Then they
randomly place goals with boxes on them in the rooms. At this point they
actually have a solved Sokoban
puzzle. In the following stage they ``unsolve'' the level by doing reverse Sokoban moves, i.e.,
pulling boxes away from the goals. The aim of this stage is to reach a state that is far as
possible from the solved state. They do this by running an iterative deepening search of the
state space.

The complex part of this algorithm is the search for the starting state in the second stage.
The process is very memory intensive, since all the visited states have to be kept in
memory in order to avoid looping. On the other hand, the algorithm has the anytime property, i.e., it
can be stopped at any time to return a valid solution, however, letting it run longer will yield
a better solution.

In \cite{taylor2015attention} an auditory Stroop test was performed to compare the engagement of
players while playing hand-crafted Sokoban levels against levels generated by the approach of
Taylor and Parberry~\cite{taylor2011procedural}. The experiment showed that players found
procedurally generated levels equally interesting to hand-crafted levels. This demonstrates
that there is entertainment value in procedurally generated puzzles.

Kartal et al.~\cite{kartal2016data} propose a Monte Carlo tree search (MCTS) based Sokoban level
generator. They formulate puzzle generation as an MCTS optimization problem such that the puzzles
are generated through simulated gameplay. The search process starts with a level full of walls except
for one tile, which contains the player in its start position. The following actions are possible at each
node of the search tree:
\begin{enumerate}
\item \emph{Remove a Wall.} Choose a wall that is adjacent to an empty tile and remove it. By only removing walls
adjacent to empty tiles they can ensure that no unreachable rooms are generated.
\item \emph{Place a Box.} Choose an empty tile and put a box there.
\item \emph{Freeze the Level.} With this action the search is changed to play mode. Removing walls and placing
boxes is not allowed after this action. The current positions of walls, boxes and the player constitute
the starting state of the level (without any goal positions, they will be defined later).
\item \emph{Move the Player.} Simulate play by executing legal moves of the player, i.e., walking
around and pushing boxes.
\item \emph{Evaluate the Level.} This is the final action of each search path. The current positions of the boxes
are declared to be the goal locations and the quality of the generated level is estimated based on data driven
evaluation functions.
\end{enumerate}

Similarly to the previously presented method, this generator also has the anytime property. It is capable of
producing a wide variety of levels thanks to its stochastic nature. Nevertheless, like all the presented approaches,
it has its limitations and the generation of large puzzles remains a bottleneck as the
number of possible level designs grows exponentially.

An up-to-date survey on procedural puzzle generation~\cite{de2019procedural} gives an overview
of the methods for generating puzzles for many games similar to Sokoban.

\section{Puzzle Generation as Planning}
Our proposed approach is based on the idea of using automated planners to generate solvable Sokoban levels.
This means that our only task is to express the problem of level generation in PDDL and the rest is taken care of
by the planning tool. We will formulate the problem of Sokoban level generation as an extension of Sokoban
level solving.

\subsection{Sokoban Solving as Planning}
Using automated planning to solve Sokoban is not a new idea by any means. Actually, Sokoban is one of the
standard benchmark problems used to evaluate new planning algorithms and tools in many academic papers
and the international planning competition~\cite{ipc}. Nevertheless, in order to keep this paper self-contained,
we will present a simple PDDL encoding of Sokoban in this Subsection.

To encode Sokoban solving we will only require one kind of objects -- squares. We will have one
object of type square for each location in the level that is not a wall. Additionally, we will
need the following predicates:
\begin{enumerate}
\item \verb _(above ?a ?b - square)_ meaning that square "a" is above square "b"
\item \verb *(left_of ?a ?b - square)* meaning that square "a" is on the left side of square "b"
\item \verb *(box_at ?a - square)* meaining that there is a box at square "a"
\item \verb *(worker_at ?a - square)* meaining that there is the worker at square "a"
\end{enumerate}
To complete the domain description we need to specify the operators. We will need two kinds
of operators -- move and push and we will need 4 of each for the 4 cardinal directions (up, down, left, right).
Fist, we will describe the move-up operator:
\begin{verbatim}
(:action move_up
  :parameters (?from ?to - square)
  :precondition(and
    (above ?to ?from)
    (worker_at ?from)
    (not (box_at ?to))
  )
  :effect (and
    (not (worker_at ?from))
    (worker_at ?to)
  )
)
\end{verbatim}
The operators for moving down, left, and right are analogous, they only differ on the line with
\verb *(above ?to ?from)* where move-down has \verb *(above ?from ?to)*, move-left has
\verb *(left_of ?to ?from)* and move-right has \verb *(left_of ?from ?to)*.
Next we describe the push-up operator:
\begin{verbatim}
(:action push_up
  :parameters (?from ?to ?box_to - square)
  :precondition(and
    (above ?to ?from)
    (above ?box_to ?to)
    (worker_at ?from)
    (box_at ?to)
    (not (box_at ?box_to))
  )
  :effect (and
    (not (worker_at ?from))
    (worker_at ?to)
    (not (box_at ?to))
    (box_at ?box_to)
  )
)
\end{verbatim}
Like int the case of move operators, the other three push operators (push down, left, and right) only differ
on the lines with the "above" predicates.

What remains is to specify the initial state and the goal conditions. For the initial state we need to declare
the following predicates:
\begin{enumerate}
\item \verb *(above a b)* for each pair of non-wall squares such that "a" is above "b".
\item \verb *(left_of a b)* for each pair of non-wall squares such that "a" is on the left side of "b".
\item \verb *(box_at a)* for each square "a" that contains a box.
\item \verb *(worker_at a)* for the square "a" that contains the worker.
\end{enumerate}
As for the goal conditions, we only need to specify that the goal squares must contain a box:
\begin{enumerate}
\item \verb *(box_at a)* for each square "a" that contains a goal.
\end{enumerate}
An example of a Sokoban level and its encoding in given on Figure~\ref{fig-solve-example}.

\begin{figure}
\begin{subfigure}[b]{0.35\textwidth}
\centering
\w\w\w\w\e\n
\w\e\p\w\e\n
\w\x\w\w\w\n
\w\e\x\g\w\n
\w\g\w\w\w\n
\w\w\w\e\e\n
\vspace{1em}
\end{subfigure}
\begin{subfigure}[b]{0.65\textwidth}
\begin{verbatim}
(:objects
  s11 s12 s21 s31 s32 s33 s41 - square
)
(:init
  (above s11 s21) (above s21 s31)
  (above s31 s41) (left_of s11 s12)
  (left_of s31 s32) (left_of s32 s33)
  (box_at s21) (box_at s32) (worker_at s12)
)
(:goal (and
  (box_at s41) (box_at s33)
))
\end{verbatim}

\end{subfigure}
\caption{A Sokoban level (left) and its encoding in PDDL (right)}
\label{fig-solve-example}
\end{figure}

\subsection{Level Creation as Planning}
As we already mentioned in the introduction, our generator is meant to assist a
human designer and not just generate fully random levels (as is the case in the
related work presented in Section~\ref{sec-related}). Therefore we allow the
user to specify the size of the puzzle by defining the outer walls. The goal
positions are also set by the designer.
% Therefore we start with a partially built level that must already contain the outer walls of the puzzle (the
% border that encloses the puzzle) and all the goal positions. However, additional walls, boxes and even the
Additional walls, boxes and even the
worker position may be defined as well. Lastly, the designer specifies which of the remaining free squares may contain
a wall, a box, a worker, or some combination of the three. The last thing to define
is the number of walls and boxes to be added to the puzzle.
If no worker position has been specified in the input then
the worker will be added automatically. We will refer to this input as a \emph{level template}.
Figure~\ref{fig-input} contains an example of a level template, the
corresponding starting puzzle and final puzzle.

\begin{figure}
% p sokogen 1 2 0   // this line means we want to add 1 wall and 2 boxes
\begin{verbatim}
p sokogen 1 2 0   // add 1 wall and 2 boxes, 0 minimum pushes (see end of section)
####              // symbols: # - wall             $ - box
#2.#              //          @ - worker           . - goal
#00###            //          + - worker on goal   * - box on goal
#.333#            // The numbers specify which tokens can be placed:
# 333#            //   0 - any     3 - box              6 - wall or box
#22###            //   1 - worker  4 - worker or wall
####              //   2 - wall    5 - worker or box
\end{verbatim}
\centering
\w\w\w\w\e\e\e\e\w\w\w\w\e\e\n
\w\e\g\w\e\e\e\e\w\w\g\w\e\e\n
\w\e\e\w\w\w\e\e\w\e\p\w\w\w\n
\w\g\e\e\e\w\e\e\w\g\x\x\e\w\n
\w\e\e\e\e\w\e\e\w\e\e\e\e\w\n
\w\e\e\w\w\w\e\e\w\e\e\w\w\w\n
\w\w\w\w\e\e\e\e\w\w\w\w\e\e\n

\caption{An example input file for our Sokoban puzzle generator (top), the starting puzzle (down left)
and the final solvable level (down right).}
\label{fig-input}
\end{figure}

Transforming a level template into a solvable level will be task of the automated planner. In order to do this
we must model the problem in PDDL. The PDDL model is an extension of the model used for solving Sokoban puzzles
that we described in the previous Subsection. We will add four new operators:
\begin{enumerate}
\item \emph{Add wall.} This operator adds a wall to one of the squares that free and is allowed to contain a wall
according to the level template.
\item \emph{Add box.} Like the "add wall" operator, but for adding a box.
\item \emph{Add worker.} Like the previous two but adds the worker.
\item \emph{Start playing.} This operator means that we transition from the level creation phase to the playing
phase of the planning problem. No more walls, boxes or workers can be added after this action is executed. Move and push actions
are not allowed to happen before this action.
\end{enumerate}

We also need to modify the goal conditions. For Sokoban solving we only required that all goal positions
contain a box. Now we also require that the specified number of walls and boxes was placed. To model
this we introduce two new types: wall and box. Then we declare as many objects of both types as
we need to add according to the level template. For example, if we need to add 3 walls and 5 boxes, then
3 objects of type wall and 5 objects of type box are declared. Then with the help of two new predicates:
\verb *(wall_placed ?w - wall)* and \verb *(box_placed ?b - box)* we can encode that all the additional walls
and boxes have been placed.

In the initial state we must specify which squares may contain additional walls, boxes, or the player.
For this purpose we introduce three new predicates: \verb *(opt_wall ?s - square)* for walls,
\verb *(opt_box ?s - square)* for boxes, and \verb *(opt_worker ?s - square)* for the workers.

To implement the \emph{start playing} operator we will define two new predicates:
\verb *(making_level)* and \verb *(playing)* to represent the current phase of the puzzle generation.
The \verb *(making_level)* is added to the initial state of problem definition, since we always start in
this phase.

Now that we have defined all the new predicates we can model the four new operators in PDDL. We start
with operators to place walls and boxes.

\begin{verbatim}
(:action place_wall          (:action place_box
  :parameters(                 :parameters(
    ?w - wall ?to - square       ?b - box ?to - square
  )                            )
  :precondition(and            :precondition(and
    (making_level)               (making_level)
    (opt_wall ?to)               (opt_box ?to)
    (not (wall_placed ?w))       (not (box_placed ?b))
    (not (wall_at ?to))          (not (wall_at ?to))
    (not (box_at ?to))           (not (box_at ?to))
  )                            )
  :effect(and                  :effect(and
    (wall_at ?to)                (box_at ?to)
    (wall_placed ?w)             (box_placed ?w)
  )                            )
)                            )
\end{verbatim}
The "place worker" and "start playing" are defined next. Note, that "place worker" also changes the phase
to playing. This way we can ensure that the worker is added last and only once. Thanks to this property the
operators to place the walls and the boxes do not need to check whether a worker has been placed on the square
the wish to place their item.

\begin{verbatim}
(:action place_player_and_start   (:action start_play
  :parameters(?to - tile)           :parameters()
  :precondition (and                :precondition(and
    (making_level)                    (making_level)
    (opt_player ?to)                )
    (not (wall_at ?to))             :effect(and
    (not (box_at ?to))                (not (making_level))
  )                                   (playing)
  :effect(and                       )
    (player_at ?to)               )
    (not (making_level))
    (playing)
  )
)
\end{verbatim}
Lastly, the move and push operators from the Sokoban solving domain need to be slightly updated.
The predicate \verb *(playing)* must be added to preconditions. With this we have described a correct and
complete encoding of the Sokoban puzzle generation into PDDL. However, there is one small issue we need to
address.

Planners always try to find short plans. This has an unpleasant consequence for our problem.
The planner is motivated to
place the walls and boxes in such a way, that the generated puzzle can be solved with as few moves and
pushes as possible. This means, that the generated levels tend to be very easy to solve.
In order to address this issue, we modeled a mechanism, that enforces a certain minimum amount of
pushes in the solve phase. This value can be specified by the puzzle designer as the third
parameter on the "p line" in the level template (see Figure~\ref{fig-input}).
This is modeled by adding a counter to the push operators, that is increased with each push action.
Then in the goal conditions we can require that the counter reaches the required value.

For more details refer to the complete domain PDDL file available in project's 
repository\footnote{\url{https://github.com/biotomas/sokoplan/blob/master/SokoGen/domain.pddl}}.
The repository also contains the tool that generates the PDDL problem files given a level template.


\subsection{Comparison to related work}
Our method bears the most similarity to the approach of Kartal et al.~\cite{kartal2016data} (see Section~\ref{sec-related}.
They formulate the puzzle generation as an MCTS optimization problem, while we model it as a planning
problem. They start with a level that contains the worker and is otherwise full of walls and then remove some
walls and add some boxes. We start with
a partially built level that already contains all the goals and then we add additional walls, boxes and the worker.
Then both approaches have a special action that transitions the search into the playing mode.
Finally, in our approach we try to solve the level and backtrack to level building phase if it is not solvable.
In Kartal et al.~\cite{kartal2016data} random moves are executed for some time and then the reached state is
declared to be the goal state.

\subsection{Generalization to other puzzles than Sokoban}
It easy to use our puzzle generation concept for other puzzles as well. In order to
do that one must only write the appropriate PDDL domain file and a generator for the PDLL problem files. 
The domain file is usually written by hand and problem files are generated by a script or a small program,
however, both can be written by hand. In any case, the effort is very low in comparison to designing and
implementing a dedicated puzzle generator for a specific puzzle as is done in related work.
Another advantage of our concept is, that as the state-of-the-art planners evolve and their performance
improves, our puzzle generator improves with it automatically.

\section{Experimental Evaluation}

\renewcommand{\sokoimg}[1]{\includegraphics[scale=0.9]{#1} \hspace{-0.35em}}
\begin{figure}
\centering
\e\n
\w\w\w\w\w\w\w\e \w\w\w\w\w\e\e\e\e\e\e \w\w\w\w\w\e\e\w\w\w\w\w\n
\w\g\g\e\g\g\w\e \w\g\g\g\w\e\e\e\e\e\e \w\g\g\g\w\e\e\w\g\g\g\w\n
\w\e\e\g\e\e\w\e \w\g\e\g\w\e\e\e\e\e\e \w\g\e\g\w\e\e\w\g\e\g\w\n
\w\e\e\g\e\e\w\e \w\e\e\e\w\w\w\w\w\w\e \w\e\e\e\w\w\w\w\e\e\e\w\n
\w\g\g\e\g\g\w\e \w\g\e\e\e\e\e\e\g\w\e \w\g\e\e\e\e\e\e\e\e\g\w\n
\w\w\w\w\w\w\w\e \w\g\g\e\e\g\g\g\g\w\e \w\g\g\e\e\g\g\g\g\g\g\w\n
\e\e\e\e\e\e\e\e \w\w\w\w\w\w\w\w\w\w\e \w\w\w\w\w\w\w\w\w\w\w\w\n
\e\n
\w\w\w\w\w\e\e\w\w\w\w\w\e \e\e\e\w\w\w\w\e\w\w\w\w\e\e\e\n
\w\g\g\g\w\e\e\w\g\g\g\w\e \e\e\e\w\g\g\w\e\w\g\g\w\e\e\e\n
\w\e\e\e\w\w\w\w\e\e\e\w\e \w\w\w\w\e\e\w\w\w\e\e\w\w\w\w\n
\w\e\e\e\e\g\g\e\e\e\e\w\e \w\g\e\e\e\e\e\e\e\e\e\e\e\g\w\n
\w\e\e\e\w\w\w\w\e\e\e\w\e \w\g\e\e\e\e\e\e\e\e\e\e\e\g\w\n
\w\g\g\g\w\e\e\w\g\g\g\w\e \w\w\w\w\e\e\w\w\w\e\e\w\w\w\w\n
\w\w\w\w\w\e\e\w\w\w\w\w\e \e\e\e\w\g\g\w\e\w\g\g\w\e\e\e\n
\e\e\e\e\e\e\e\e\e\e\e\e\e \e\e\e\w\w\w\w\e\w\w\w\w\e\e\e\n
\e\n
\e\e\e\w\w\w\w\w\e\e\e\e \w\w\w\w\w\e\e\e\e \w\w\w\w\w\w\w\w\w\w\n
\e\e\e\w\g\g\g\w\e\e\e\e \w\g\g\g\w\e\e\e\e \w\g\g\g\e\e\e\g\g\w\n
\w\w\w\w\e\e\e\w\w\w\w\e \w\g\e\g\w\e\e\e\e \w\g\e\e\e\e\e\e\g\w\n
\w\g\e\e\e\w\e\e\e\g\w\e \w\e\w\e\w\w\w\w\e \w\w\w\w\e\e\w\w\w\w\n
\w\g\e\e\e\w\e\e\e\g\w\e \w\e\w\e\e\e\g\w\e \e\e\e\w\g\g\w\e\e\e\n
\w\w\w\w\e\e\e\w\w\w\w\e \w\g\g\e\e\g\g\w\e \w\w\w\w\e\e\w\w\w\w\n
\e\e\e\w\g\g\g\w\e\e\e\e \w\w\w\w\w\w\w\w\e \w\g\e\e\e\e\e\e\g\w\n
\e\e\e\w\w\w\w\w\e\e\e\e \e\e\e\e\e\e\e\e\e \w\g\g\g\e\e\e\g\g\w\n
\e\e\e\e\e\e\e\e\e\e\e\e \e\e\e\e\e\e\e\e\e \w\w\w\w\w\w\w\w\w\w\n
\e\n
\w\w\w\w\w\w\w\w\w\w\w\w\w\e \w\w\w\w\w\w\w\w\w\w\w\w\w\w\n
\w\g\g\g\e\g\g\g\e\e\g\g\w\e \w\g\g\g\e\e\g\g\e\e\g\g\g\w\n
\w\g\e\e\e\e\e\e\e\e\e\g\w\e \w\g\e\e\e\e\e\e\e\e\e\e\g\w\n
\w\w\w\w\e\w\w\w\e\w\w\w\w\e \w\w\w\w\e\e\w\w\e\e\w\w\w\w\n
\e\e\e\w\e\w\e\w\e\w\e\e\e\e \e\e\e\w\e\e\w\w\e\e\w\e\e\e\n
\w\w\w\w\e\w\w\w\e\w\w\w\w\e \w\w\w\w\e\e\w\w\e\e\w\w\w\w\n
\w\g\e\e\e\e\e\e\e\e\e\g\w\e \w\g\e\e\e\e\w\w\e\e\e\e\g\w\n
\w\g\g\g\e\g\g\g\e\e\g\g\w\e \w\g\g\g\g\g\w\w\g\g\g\g\g\w\n
\w\w\w\w\w\w\w\w\w\w\w\w\w\e \w\w\w\w\w\w\w\w\w\w\w\w\w\w\n
%TODO uncomment
\caption{The 10 meta templates we used to generate our 300 benchmark level templates. The
name of the meta templates are (top left to bottom right): O, L, U, H, XX, X, B, I, II, and Pi.}
\label{fig-meta-templates}
\end{figure}

Our Sokoban puzzle generation tool is available online at github\footnote{\url{https://github.com/biotomas/sokoplan}}.
The repository contains everything you need build and use our tool and also to replicate
the experimental evaluation we present in this section.

\subsection{Setup}
As our tool is based on planning, we will obviously need a planner. Any planner that supports PDDL\footnote{All available academic planners support PDDL} would work, but based on some preliminary evaluations we
settled on using the well established state-of-the-art planner FastDownward~\cite{helmert2006fast} with
the LAMA~2011~\cite{richter2011lama} configuration.

We generated 300 level templates to use as benchmarks (more on how is described in the next Subsection)
and we gave the planner a time limit of 1 minute to find a solvable puzzle. We run our experiments
on a computer with an Intel(R) Core(TM) i7-7800X CPU @ 3.50GHz processor and 64 GB of main memory.
The used operating system was Ubuntu version 5.8.0-26-generic.

\subsection{Benchmark Instances}
All of the 300 level templates are based on 10 base templates, which we designed by hand (see
Figure~\ref{fig-meta-templates}). To create the benchmark templates of various complexities
we reduced the number of goals in the base templates to a certain number. 
A benchmark template of complexity level $x$ is defined as a template with $x$ goal locations and
the objective to add $x$ walls and $x$ boxes.
We generated templates of complexity levels $1,2,\ldots,6$. We created 5 templates for each of 
the 6 complexity levels and each of the 10 base templates, hence the 300 total benchmark templates.

To create a template of complexity level $x$ from a base template we first mark each floor square
as a potential position for adding any (wall, box, or worker) object. Then we randomly remove
goal squares until exactly $x$ goal squares remain. An example of generating a template of complexity
level 4 from a base template follows:
\begin{verbatim}
base temp.    p sokogen 4 4 4  // objective:
#####         #####            //     add 4 walls and 4 boxes
#...#         #.  #            //     do 4 at least pushes 
#. .#         # 0.#            // 
# # ####  =>  #0#0####         // symbols: 
# #   .#      #0#000 #         //     # - wall     
#..  ..#      #. 00. #         //     . - goal     
########      ########         //     0 - add any object
\end{verbatim}

\subsection{Experimental Results}
\begin{table}[t]
\setlength{\tabcolsep}{11pt}
\renewcommand{\arraystretch}{1.25}
\definecolor{mygray}{gray}{0.8}
\centering
\begin{tabular}{|c|c||c c c c c c|c|}
\hline
\textbf{\textbf{Base}} & \textbf{\textbf{Free}} & \multicolumn{6}{c|}{\textbf{Solved for Complexity Level}} & \textbf{Total} \\ 
\textbf{Template} & \textbf{Squares} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} & \textbf{6} & \textbf{Solved} \\ 
\hline 
\rowcolor{mygray} 
O  & 10 &   5 &  5 &  5  & 5 &  0 &  0 & 20 \\
L  & 12 &   5 &  5 &  5  & 5 &  1 &  0 & 21 \\
\rowcolor{mygray} 
U  & 18 &   5 &  5 &  5  & 2 &  1 &  1 & 19 \\
H  & 20 &   5 &  5 &  5  & 0 &  2 &  0 & 17 \\
\rowcolor{mygray} 
XX & 30 &   5 &  5 &  5  & 1 &  1 &  0 & 17 \\
X  & 18 &   3 &  3 &  1  & 1 &  0 &  0 & 8  \\
\rowcolor{mygray} 
B  & 9  &   5 &  5 &  0  & 0 &  0 &  0 & 10 \\
I  & 20 &   5 &  5 &  4  & 3 &  2 &  1 & 20 \\
\rowcolor{mygray} 
II & 28 &   5 &  5 &  3  & 4 &  0 &  0 & 17 \\
Pi & 35 &   5 &  5 &  5  & 1 &  0 &  0 & 16 \\
\hline 
\end{tabular} 
\vspace{1em}
\caption{The table contains experimental results on our benchmarks grouped by base templates and complexity
levels. The first column contains the names of the base templates, see Figure~\ref{fig-meta-templates} for
their definitions. The values in the second column are the number of free squares in the corresponding templates
that can be used to place walls, boxes and the player.
Columns 3 to 8 contain the number of solved instances within a time limit of 1 minute for each complexity level.
The final column contains the total number of solved instances within 1 minute for across all complexity
levels.}
\label{tab-results}
\end{table}

The results of the experimental evaluation are presented in Table~\ref{tab-results}.
Not solving a level template can either mean that it is impossible to place the given amount of walls
and boxes such that a solvable level is created or that the planner could find in a solution in the given
time limit (of 1 minute). Unfortunately, in most cases, we cannot distinguish between these two scenarios,
since planners are not very good at proving non-existence of plans.

For most of the base templates we could solve around 20 of the 30 level templates, except for X and B,
which seem to be to tight to add more than 2 walls and 2 boxes in most of the cases.
On the large base templates (XX, II, and Pi) we failed to solve most of the higher complexity templates. We
believe that this is not due to the not existence of solutions, rather it is caused by the inability of
the planner to find a solution within the given time limit.
We could add 6 boxes and walls only for base templates U and I, which with 18 and 20 free squares
represent middle sized levels. This seems to be the sweet spot between being to tight to place
enough objects and too large to find a solution within the time limit.

Overall, the experimental evaluation showed that our approach works and we can rapidly
generate levels of various shapes and complexities. 

\section{Conclusion}
We presented a method to assist human level designers to generate solvable Sokoban
puzzles using automated planners. Our method has several advantages. Firstly,
it based on a very generic principle (using planners) so it can be easily modified and used
to generate other than Sokoban puzzles. Secondly, it is using a constantly
evolving search technology (automated planning) so the generator will automatically
improve with time as planners get more and more performant. Thirdly, it is very simple
and easy to implement and customize.

\subsection{Future Work}
As for future work we would like to improve the performance of our tool by tuning the PDDL
encoding and adjusting the configuration parameters of the used planner or evaluate
other available planners.

We plan to develop a user friendly graphical user interface (GUI) for our generator
to make it easy to use for less technical users.

Finally, we would like to test or general method on other puzzles than Sokoban. As described in
the paper, this mostly only amounts to formulating new PDDL models for the given puzzles.

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{references, literatur}
%
\end{document}
